{"posts":[{"title":"[HEOI2015]最短不公共子串","content":"给两个小写字母串 a,ba, ba,b，请你计算： 1.1.1. aaa 的一个最短的子串，它不是 bbb 的子串。 2.2.2. aaa 的一个最短的子串，它不是 bbb 的子序列。 3.3.3. aaa 的一个最短的子序列，它不是 bbb 的子串。 4.4.4. aaa 的一个最短的子序列，它不是 bbb 的子序列。 串长不超过 200020002000。 对于前两问，我们可以先枚举 aaa 的子串的开头位置，接下来在 bbb 的后缀自动机/序列自动机上沿着转移边走，走不动时所走的长度就是以这个位置开头能匹配的 bbb 的最长子串。 对于后两问，注意到自动机的性质：如果当前确定了在哪个状态，那么剩下的能走的步数是与前面如何到达这个状态无关的。因此贪心地走最短路到达这个状态即可。因此考虑广搜，设 f[i][j]f[i][j]f[i][j]表示到达 aaa 的自动机的状态 iii 并且到达 bbb 的自动机的状态 jjj 的最少步数。每次枚举 iii 的转移边，如果 jjj 也有这条转移，则放入队列中；否则就与 bbb 失配，直接输出当前的 f+1f+1f+1 即可。 ","link":"https://theforthpole.github.io/post/heoi2015zui-duan-bu-gong-gong-zi-chuan/"}]}